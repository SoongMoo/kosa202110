*** JAVA 질문

* 클래스변수, 지역변수, 인스턴스 변수에 대해서 설명, 선언위치 설명

자바에서의 변수는 클래스 변수, 인스턴스 변수, 지역 변수가 있습니다. 

변수의 종류를 결정짓는 것은 '변수가 선언된 위치' 입니다.

public class test {

	int iv; // 인스턴스 변수
	static int cv; // 클래스 변수
	
	void method() {
		int lv; // 지역 변수
	}
}

인스턴스 변수

 인스턴스 변수는 인스턴스가 생성될 때 생성됩니다. 

그렇기 때문에 인스턴스 변수의 값을 읽어오거나 저장하려면 인스턴스를 먼저 생성해야합니다. 

인스턴스 별로 다른 값을 가질 수 있으므로, 각각의 인스턴스마다 고유의 값을 가져야할 때는 인스턴스 변수로 선언합니다.


클래스 변수

  클래스 변수는 인스턴스 변수에 static만 붙여주면 됩니다. 

인스턴스 변수는 각각 고유한 값을 가지지만 클래스 변수는 모든 인스턴스가 공통된 값을 공유하게 됩니다. 

한 클래스의 모든 인스턴스들이 공통적인 값을 가져야할 때 클래스 변수로 선언합니다. 

클래스가 로딩될 때 생성되어(그러므로 메모리에 딱 한번만 올라갑니다.) 종료 될 때 까지 유지되는 클래스 변수는 public 을 붙이면 같은 프로그램 내에서 어디서든 접근할 수 있는 전역 변수가 됩니다. 

또한 인스턴스 변수의 접근법과 다르게 인스턴스를 생성하지 않고 클래스이름.클래스변수명 을 통해서 접근할 수 있습니다.


지역 변수

 메서드 내에서 선언되며 메서드 내에서만 사용할 수 있는 변수입니다. 

메서드가 실행될 때 메모리를 할당 받으며 메서드가 끝나면 소멸되어 사용할 수 없게 됩니다.




* 추상클래스와 인터페이스의 공통점 차이점

인터페이스 (Interface)
- 일종의 추상 클래스
- 오직 추상메서드와 상수만을 멤버로 갖는다.
- Implements 키워드를 사용
- 상속의 관계가 없는 클래스간 서로 공통되는 로직을 구현하여 쓸 수 있도록한다.
- Extends는 하나의 클래스만 상속 가능하나 Interface는 다중 상속이 가능하다.

추상 클래스(Abstract)
- 추상메서드를 하나 이상 가진 클래스
- 자신의 생성자로 객체 생성 불가능
- 하위 클래스를 참조하여 상위 클래스의 객체를 생성
- 하위 클래스를 제어하기 위해 사용


추상 클래스(Abstract)
클래스를 설계도에 비유한다면 추상클래스는 미완성 설계도에 비유할 수 있다. 미완성 설계도란, 단어
의 뜻 그대로 완성되지 못한 채로 남겨진 설계도를 말한다. 클래스가 미완성이라는 것은 멤버의 개수에
관계된 것이 아니라, 단지 미완성 메서드(추상메서드)들 포함하고 있다는 의미이다. 미완성 설계도로
완성된 제품을 만들 수 없듯이 추상클래스로 인스턴스는 생성할 수 없다. 추상클래스는 상속을 통해서
자손클래스에 의해서만 완성될 수 있다.
**자바의 정석 참고**

인터페이스 (Interface)
인터페이스는 일종의 추상클래스이다. 인터페이스는 추상클래스처럼 추상메서드를 갖지만 추상클래스 보다 추상화 정도가 높아서 추상클래스와는 달리 몸통을 갖춘 일반 메서드 또는 멤버변수를 구성원으 로 가질 수 없다. 오직 추상메서드와 상수만을 멤버로 가질 수 있으며, 그 외의 어떠한 요소도 허용하지 않는다. 추상클래스를 부분적으로만 완성된 '미완성 설계도'라고 한다면, 인터페이스는 구현된 것은 아 무것도 없고 밑그림만 그려져 있는 '기본 설계도'라고 할 수 있다. 인터페이스는 인터페이스로부터만 상속받을 수 있으며, 클래스와는 달리 다중상속, 즉 여러개의 인터페이스로부터 상속을 받는 것이 가능 하다.
**자바의 정석 참고**




* 인터페이스, 상속, 다형성에 대해서 설명

- 인터페이스

인터페이스는 일종의 추상클래스이다. 인터페이스는 추상클래스처럼 추상메서드를 갖지만 추상클래스
보다 추상화 정도가 높아서 추상클래스와는 달리 몸통을 갖춘 일반 메서드 또는 멤버변수를 구성원으
로 가질 수 없다. 오직 추상메서드와 상수만을 멤버로 가질 수 있으며, 그 외의 어떠한 요소도 허용하지
않는다. 추상클래스를 부분적으로만 완성된 '미완성 설계도'라고 한다면, 인터페이스는 구현된 것은 아
무것도 없고 밑그림만 그려져 있는 '기본 설계도'라고 할 수 있다. 인터페이스는 인터페이스로부터만
상속받을 수 있으며, 클래스와는 달리 다중상속, 즉 여러개의 인터페이스로부터 상속을 받는 것이 가능
하다.
  +++ 남궁성저 Java의 정석 참고 +++

- 다형성
여러가지 데이터를 다룰 수 있는 특성을 뜻한다.
조상클래스의 인스턴스를 이용하여 자손타입의 클래스를 다룬다거나, 메서드 오버로딩을 통하여
동일 이름의 메서드를 이용하여 다양한 형태의 파라미터를 다루는 것을 뜻한다.

- 상속
하위 클래스를 참조하여 상위 클래스의 객체를 생성(?)





* 배열과 List의 차이점

1. CPU의 처리 속도에서 배열이 리스트보다 훨씬 더 빠르다.

인덱스 번호가 3인 데이터에 접근한다고 가정하자. 배열은 인덱스 번호 3을 이용하여 곧바로 그 위치의 데이터에 직접 접근할 수 있다. 그러나 리스트는 0번 위치의 데이터를 기점으로 3개의 화살표를 오른쪽으로 따라가야 비로소 3번 위치의 데이터에 도달할 수 있다. 여기서 리스트는 배열처럼 인덱스 번호를 이용하여 직접 접근할 수 없다는 것이다. 반드시 0번 위치부터 화살표를 따라가야 하며, 그때 따라간 화살표의 개수를 세야 한다. 당연히 배열 보다 느릴 수밖에 없다.

2. 이들 자료 구조를 이용하여 해결하려고 하는 문제의 특성에 따라, 리스트와 배열의 유용성이 상당히 달라진다. 어떤 문제는 리스트를 사용하는 것이 더 좋고, 어떤 문제는 배열을 사용하는 것이 더 좋다. 이렇게 자료 구조의 유용성을 다르게 하는 문제의 특성이란 무엇일까? 바로 “데이터들의 묶음에서, 삽입 또는 삭제될 위치에 있는 데이터의 처리”에 있다. 그 위치의 처리 상황은 삽입과 삭제 시 각각 두 가지 경우가 있을 수 있다.

새로운 데이터의 삽입 시

- 삽입할 위치에 있던 기존의 데이터를 그냥 덮어 쓰는 경우

- 삽입 위치의 데이터와 그 이후의 데이터를 한 칸씩 뒤로 밀어서 삽입할 공간을 만들어야 하는 경우

기존 데이터의 삭제 시

- 삭제되고 남아 있는 공간을 그대로 두는 경우

- 삭제 위치 이후의 데이터들을 한 칸씩 앞으로 밀어서 삭제된 공간을 메워야 하는 경우

삽입과 삭제 시 전자에 해당하는 경우는 배열을, 후자에 해당하는 경우는 리스트를 사용하는 것이 프로그래밍을 하기에 편리하다.




* inner클래스(내부클래스)의 사용 용도와 장점

inner 클래스 : 일반 클래스 내에 정의되어 있는 또 다른 클래스를 말하는 것

내부클래스인 B는 외부클래스인 A를 제외하고는 다른 클래스에서 사용되지 않아야한다.

사용용도

 정적 클래스
(Static Inner Class)
외부 클래스를 인스턴스화 하지 않아도 바로 사용 가능한 내부 클래스

외부 클래스를 간편하게 사용하기 위한 목적으로 일반 클래스를 대상으로 노출을 시키는 클래스 입니다. 대표적인 예가 Builder 패턴의 Builder 클래스 이죠.

 멤버 클래스
(Member Class)
외부 클래스의 필드나 메서드를 사용할 수 있지만 내부 클래스는 외부 클래스가 인스턴스화 된 후부터 동작한다.

일반적으로 외부 클래스의 기능이나 속성중 하나를 구분지어 사용하며, 외부 클래스의 필드나 기능과 유기적으로 연동하여 구현 합니다.
거대한 외부 클래스의 가독성을 높히기 위한 방법 중 하나로 사용 합니다.

 지역 클래스
(Local Class)
메서드 내에서 국한되어 사용되는 내부 클래스이며, 메서드 내의 지역 변수를 사용할 수 있다. 다만 final로 정의해야한다. 그 이유는 메서드 동작이 종료된 후에 클래스의 동작이 종료되지 않을 수 있기 때문이다.

함수내에서 간단한 비동기적 처리를 위해 객체를 만들어 사용할 때 쓰입니다.

 익명 클래스
(Anonymous Class) 
일반적으로 객체를 인스턴스화 하면서 오버라이드 메서드를 구현하는 형태를 말한다. 

추상화 되어 있는 클래스를 재정의 하여 전역필드로 사용할 때 쓰이곤 합니다.
	
.내부클래스의 장점

- 내부클래스에서 외부클래스의 멤버들을 쉽게 접근할 수 있다. 
- 코드의 복잡성을 줄일 수 있다.(캡슐화)



* 오버로딩과 오버라이딩에 대해서 설명

오버로딩(Overloading)
- 같은 이름의 메소드를 여러개 정의하는 것
- 매개변수의 타입이 다르거나 개수가 달라야 한다.
* return type과 접근 제어자는 영향을 주지 않음.
 
Overriding(오버라이딩)
- 상속에서 나온 개념
- 상위 클래스(부모 클래스)의 메소드를 하위 클래스(자식 클래스)에서 재정의




* primitive type, reference type 에 대해서 설명

Primitive Type은 변수에 값 자체를 저장하며 Reference Type은 메모리상에 객체가
있는 위치를 저장한다.
Primitive Type의 종류는 boolean, byte, char, short, int, float, long, double 총 8가지 이며
Reference Type 종류는 클래스타입, 인터페이스타입, 배열타입, 열거타입이 있다. 
  +++ 김윤명저 뇌를 자극하는 Java 프로그래밍 참고 +++  




* stack과 queue, LinkedList 설명

- 스택 (stack) : 자료를 순서대로 쌓아서 보관하고 사용한다. LIFO ( Last In First Out ) :  후입선출, 사용되는 함수로는 Push와 Pop가 있겟습니다. (Push : 자료넣기&입력, Pop : 자료빼기&삭제 

- 큐 (queue ) : FIFO ( First In First Out ) : 선입선출 이라고 불리며, 프로세스 처리, CPU 관리에서 많이 사용된다.

- LinkedList : 순서대로 늘어선 것이 아니라 자료의 주소 값으로 서로 연결되어 있는 구조를 하고 있습니다. ArrayList에서 뒤로 밀거나 채우는 작업 없이 단지 주소만 서로 연결시켜 주면 되기 때문에 추가/삭제가 ArrayList보다 빠르고 용이 합니다.

  LinkedList에서는 순차접근(sequential access) 만이 가능합니다. 특히, 단순 LinkedList는 단방향성을 갖고 있기 때문에 인덱스를 이용하여 자료를 검색하는 애플리케이션에는 적합하지 않습니다.

장점	

자료의 삽입과 삭제가 용이하다.	
리스트 내에서 자료의 이동이 필요하지 않다.	
사용 후 기억 장소의 재사용이 가능하다.	
연속적인 기억 장소의 할당이 필요하지 않다.	

단점

포인터의 사용으로 인해 저장 공간의 낭비가 있다. 
알고리즘이 복잡하다. 
특정 자료의 탐색 시간이 많이 소요된다.








*** 데이터베이스 질문

* 정보, 데이터, 데이터베이스, 데이터베이스관리시스템에 대해서 설명

- 정보 : 자료를 가공(처리)해서 얻은 결과물

- 데이터(자료) : 단순한 사실이나 결과값, 가공되지 않은 상태

- 데이터베이스 : 여러 사람에 의해 공유되어 사용될 목적으로 통합하여 관리되는 데이터의 집합을 말한다. 자료항목의 중복을 없애고 자료를 구조화하여 저장함으로써 자료 검색과 갱신의 효율을 높인다.

- 데이터베이스관리시스템(DBMS) : 연관성 있는 데이터들의 집합을 효율적으로 응용하기 위해 구성된 소프트웨어들의 집합체입니다. 즉, 데이터와 응용프로그램의 중간에서 응용프로그램이 요구하는 대로 데이터를 정의하고, 읽고, 쓰고, 갱신하는 등의 데이터를 조작하고 이들을 효율적으로 관리하는 프로그램들을 지칭합니다.

사용자가 새로운 데이터베이스를 생성하고, 데이터베이스의 구조를 명시할 수 있게 하고, 사용자가 데이터를 효율적으로 질의하고 수정할 수 있도록 합니다. 시스템의 고장이나 권한이 없는 사용자로부터 데이터를 안전하게 보호하며, 동시에 여러 사용자가 데이터베이스를 접근하는 것을 제어하는 소프트웨어 패키지입니다.




* 트랜잭션, 락 에 대해서 설명

트랜잭션은 하나의 논리적 작업 단위로 수행되는 일련의 작업입니다. 작업의 논리적 단위는 ACID(원자성, 일관성, 격리성 및 영속성) 속성이라고 하는 네 가지 속성을 통해 트랜잭션으로서의 자격을 부여합니다.

-원자성
트랜잭션은 더 이상 분류할 수 없는 작업 단위여야 하며 모든 데이터 수정 작업이 수행되거나 하나도 수행되지 말아야 합니다.

-일관성
완료된 트랜잭션의 모든 데이터는 일관되어야 합니다. 관계형 데이터베이스에서는 트랜잭션 수정에 모든 규칙을 적용하여 모든 데이터 무결성을 유지해야 합니다. 트랜잭션 마지막에는 B-tree 인덱스 또는 이중 연결 목록 등 모든 내부적 데이터 구조를 반드시 수정해야 합니다.

-격리성
동시 트랜잭션에 의한 수정은 다른 동시 트랜잭션에 의한 수정과 격리되어야 합니다. 트랜잭션에서 다른 동시 트랜잭션이 수정하기 전 상태의 데이터를 보거나 두 번째 트랜잭션이 완료된 후의 데이터를 볼 수는 있지만 중간 상태는 볼 수 없습니다. 결과적으로 시작 데이터를 다시 로드하고 일련의 트랜잭션을 재생하여 원래 트랜잭션이 수행된 후의 상태로 데이터를 되돌릴 수 있는데 이를 순차성이라고 합니다.

-영속성
완전 내구성이 있는 트랜잭션이 완료되고 나면 그 영향이 영구적으로 시스템에 적용됩니다. 수정은 시스템에 오류가 발생한 경우에도 지속됩니다. SQL Server 2014고 나중에 지연 된 내구성이 있는 트랜잭션을 사용 하도록 설정 합니다. 지연된 영구적 트랜잭션은 트랜잭션 로그 레코드가 디스크에 유지되기 전에 커밋됩니다. 내구성이 지연 된 트랜잭션 대 한 자세한 내용은 항목을 참조 트랜잭션 내 구성은합니다.

SQL 프로그래머는 적시에 트랜잭션을 시작하고 끝내 데이터의 논리적 일관성을 유지하는 책임을 맡고 있습니다. 프로그래머는 조직의 업무 규칙과 관련하여 데이터를 일관된 상태로 유지할 수 있도록 데이터 수정 순서를 정의해야 합니다. 그런 다음 이러한 수정 문을 하나의 트랜잭션에 포함하여 SQL Server 데이터베이스 엔진가 트랜잭션의 물리적 무결성을 유지할 수 있게 해야 합니다.

트랜잭션 중일 때 테이블 잠금(Lock)이 발생한다.
잠금(Lock)은 사용자가 데이터를 사용하고 있으면 다른 사용자가 그 데이터를 변형하지 못하도록 한다.

따라서, 테이블이 잠기면 이 잠금이 풀릴 때까지 다른 쿼리 수행은 잠금이 풀릴 때까지 대기하게 된다.

잠금이 사용되어야 하는 근본적인 이유 중 하나는 "일관성(Consistency)"이다.

데이터베이스의 중요한 사항 중의 하나인 일관성은 
"동시에 여러 사용자가 같은 데이터에 접근하려고 할 때" 발생하는 상황을 뜻한다.




* self join, inner join, left outer join, right outer join, full outer join 에 대해서 설명

1. INNER JOIN
두개의 관련된 키가 있는 테이블에서 Column의 값을 비교 후
Join 조건에 맞는 행만 검색합니다. 
SQL서버의 기본 조인 방식 입니다.

조인의 구현 - ANSI SQL 문법
SELECT table_name.column_name [, table_name.column_name…]
FROM {table_name[join_type] JOIN table_name ON search_conditions}
WHERE [search_condition…]

SELECT authors.au_lname, authors.state, publishers.*
FROM publishers INNER JOIN authors
ON publishers.city = authors.city

2. OUTER JOIN
LEFT 또는 RIGHT OUTER JOIN.
두 테이블에서 지정된 쪽인 LEFT 또는 RIGHT 쪽의
모든 결과를 보여준후 반대쪽에 대해는 매칭값이 없어도
보여주는 JOIN을 의미

SELECT title, stor_id, ord_num, qty, ord_date
FROM titles LEFT OUTER JOIN sales
ON titles.title_id = sales.title_id

3. CORSS JOIN
CROSS JOIN 연관된 두개의 테이블에서 가능한 모든 조합을 찾는다

SELECT au_fname, au_lname, pub_name
FROM authors CROSS JOIN publishers 

4. FULL OUTER JOIN
LEFT OUTER JOIN의 결과와 RIGHT OUTER JOIN의
결과를 표시한후 한번 중복되는 값(INNER JOIN의 값)의 중복을 제거한 값을 표시한다

SELECT a.au_fname, a.au_lname, p.pub_name
FROM authors a FULL OUTER JOIN publishers p
ON a.city = p.city

두 OUTER JOIN을 실행한후
겹치는 부분인 INNER JOIN의 결과 부분이 두번 나오겠지요?
이 INNER JOIN의 결과를 한번 제외한 결과 라고 생각 하심 빠릅니다.
LEFT , RIGHT 조인을 실행 한다고 생각하심 빠르다는 의미 입니다.

5. SELF JOIN
사용하는 경우 : 
1. 계층적인 구조를 테이블화 할 경우.
2. 한 테이블에서 일치하는 값을 찾고자 하는 경우.
아울러 반드시 테이블 Alias 명을 사용해 질의해야 한다

SELECT au1.au_fname, au1.au_lname, au2.au_fname, au2.au_lname, au1.zip
FROM authors au1 INNER JOIN authors au2 
ON au1.zip = au2.zip
WHERE au1.city = 'Oakland' 
and au1.au_id <> au2.au_id
ORDER BY au1.au_fname ASC, au1.au_lname ASC

테이블의 행을 같은 테이블 안에 있는 다른 행과 연관시킨다.
- 비교되는 컬럼은 같은 자료형이어야 하고 여러 방법에 대해 비교 가능해야 한다.
- 같은 테이블을 조인하기 위해서는 하나의 테이블을 두개의 다른 논리적인 테이블로 
참조 할 수 있도록 별명을 할당해야 한다.




* select, from, group by, where, having, oder by 의 처리순서 나열

FROM > WHERE > GROUP BY > SELECT > HAVING > ORDER BY




* DCL, DML, DDL 설명, 명령어 3개씩 기입

⒜ DDL : 데이터 정의 언어 

⒝ DML : 데이터 조작 언어

⒞ DCL : 데이터 제어 언어

DDL

DDL (Data Definition Language) 는 데이터 베이스 스키마를 정의 하거나 조작하기 위해 사용한다.

SCHEMA, DOMAIN, TABLE, VIEW, INDEX 를 다음 명령어로 정의, 변경, 삭제한다.


⒜ CREATE : 정의 

⒝ ALTER: 수정

⒞ DROP : 삭제

⒟ TRUNCATE : DROP 후 CREATE
* Oracle 11g 이전 버전과 MySQL은 DDL에 대해서 트랜잭션을 지원하지 않는다.

(Rollback 할 수 없고 Commit할 필요도 없다.)



DML

DML (Data Manipulation Language) 는 데이터를 조작 (조회, 추가, 변경, 삭제) 하기 위해 사용한다.

사용자가 응용 프로그램과 데이터 베이스 사이에 실질적인 데이터 처리를 위해서 주로 사용한다.



⒜ SELECT : 조회

⒝ INSERT : 추가

⒞ DELETE : 삭제

⒟ UPDATE : 변경


기본적인 위의 명령어 외에 LOCK, EXPLAIN, CALL 등도 DML에 포함 된다.


DQL

일부에서는 DML에서 SELECT 만을 따로 분리해서 DQL (Data Query Language) 나 

간단히 QUERY 로 표현하기도 한다.


DCL

DCL (Data Control Language) 는 데이터를 제어하는 언어이다.

데이터의 보안, 무결성, 회복, 병행 수행제어 등을 정의하는데 사용한다.


⒜ COMMIT : 트랜잭션의 작업 결과를 반영 

⒝ ROLLBACK : 트랜잭션의 작업을 취소 및 원래대로 복구

⒞ GRANT : 사용자에게 권한 부여

⒟ REVOKE : 사용자 권한 취소


TCL

일부에서는 DCL 에서 트랜잭션을 제어하는 명령인 COMMIT 과 ROLLBACK 만을 따로 분리해서 TCL (Transaction Control Language) 라고 표현하기도 한다.




* 무결성을 위한 제약조건 설명

- NOT NULL : NULL을 허용하지 않는다.

- UNIQUE : 중복된 값을 허용하지 않는다. 항상 유일한 값을 갖도록 한다.

- PRIMARY KEY : NULL을 허용하지 않고 중복된 값을 허용하지 않는다. NOT NULL 조건과 UNIQUE 조건을 결합한 형태이다.

- FOREIGN KEY : 참조되는 테이블의 칼럼의 값이 존재하면 허용된다.

- CHECK : 저장 가능한 데이터의 값의 범위나 조건을 지정하여 설정한 값만을 허용한다.




* 데이터베이스에서 인덱스를 사용할때의 장점

- 키 값을 기초로 하여 테이블에서 검색과 정렬 속도를 향상시킵니다.
- 질의나 보고서에서 그룹화 작업의 속도를 향상시킵니다.
- 인덱스를 사용하면 테이블 행의 고유성을 강화시킬 수 있습니다.
- 테이블의 기본 키는 자동으로 인덱스 됩니다.
- 필드 중에는 데이터 형식 때문에 인덱스 될 수 없는 필드도 있습니다.
- 여러 필드로 이루어진(다중 필드) 인덱스를 사용하면 첫 필드 값이 같은 레코드도 구분할   수 있습니다.
  참고로 액세스에서 다중 필드 인덱스는 최대 10개의 필드를 포함할 수 있습니다.










*** Web 질문

* servlet init(), destroy(), service() 설명, 호출횟수, 생명주기 설명

● 처음으로 컨테이너는 서블릿 클래스를 로딩합니다.

● 그런 다음 서블릿의 생성자를 호출하여 인스턴스화를 하죠.

● 그리고 초기화메소드인 Init() 메소드를 호출합니다. 
이 메소드는 서블릿에서 단 한번만 호출됩니다. 
또한 꼭 init() 메소드는 service() 메소드 이전에 실행되어야 합니다.
서블릿을 초기화하는 기능을 합니다. 초기화할 코드가 있다면 이 메소드를 재정의 한 후 여기에 작성하면 되겠습니다. (ex : DB 접속 등 )

● 그 다음 service() 메소드를 호출합니다. 이것은 곧 doGet() 또는 doPost() 메소드를 호출하는 것이고, 이 메소드가 호출되면 새로운 스레드를 만들어 작업 처리를 하지요. 최초의 클라이언트 요청을 받으면 컨테이너는 준비하고있던 서블릿에 대한 스레드를 생성하여 service() 메소드를 호출합니다.

스레드 풀 기능(자주 쓰는 스레드를 풀이란 곳에 넣어두고 가져오고 반환하는 방식)도 있지만 여기에선 논외로 하겠습니다. 

클라이언트의 HTTP 메소드를 분석하여 doGet() 또는 doPost() 메소드를 호출할지 여기서 결정합니다. service() 메소드는 재정의 하지 않고, doGet() , doPost() 메소드를 재 정의하여 HttpServlet 의 service() 메소드가 이것을 실행하도록 하면 됩니다.
결국, 작업처리 부분은 doGet(), doPost()에 코딩하고, 둘중 하나는 반드시 재정의 해야 합니다.
( 경우에 따라선 둘다 재정의 할 수 있습니다. )

● 작업이 끝나면 destory() 메소드를 호출하여 서블릿을 종료하는 구조입니다. 마찬가지로 이 메소드도 한번만 실행됩니다.

● Servlet 인터페이스 : init(), service(), destroy() 라는 3개의 생명주기 메소드를 가지고 있습니다.

● GenericServlet 추상클래스 : 필요한 여러개의 메소드가 있으며, Servlet 인터페이스에 정의된 메소드도 가지고 있습니다. init() 메소드가 있는점에 주목해 주세요!

● HttpServlet 추상클래스 : 서블릿의 HTTP 적인 내용을 담고있는 추상클래스입니다. service() 메소드를 재정의 합니다. init() 메소드가 없는점에 주목하세요.

● 마지막으로 사용자가 직접 코딩하는 내 서블릿 클래스는 HttpServlet 추상클래스를 상속받지요 ^^

즉, 컨테이너가 서블릿을 호출하면 init() 를 실행합니다. [ 상위의 이미지 그림을 다시 봐주시길... ]
init() 메소드를 재정의 하지 않았다면 GenericServlet 클래스의 init() 를 실행하게 되겠지요.

그런 다음 service() 메소드를 호출합니다. 이것 또한 재정의하지 않았다면 HttpServlet 클래스의 service() 메소드를 실행할 것입니다. 

다음으로 HttpServlet 클래스의 service() 메소드는 내 서블릿 클래스에 재 정의한 doGet() 또는 doPost() 메소드를 실행합니다. HttpServlet 의 doGet() , doPost() 에는 아무런 내용이 없으므로 반드시 둘중 하나 ( 또는 둘다 ) 재 정의 해야하는것. 잊지 않으셧죠?

컨테이너는 이제 새로운 요청이 들어오면 새로운 스레드를 생성합니다.
그런 뒤에 서블릿의 service() 메소드를 호출하지요. service() 메소드는 호출될때마다 doGet() 또는 doPost() 메소드를 호출하고, 이말은 곧 클라이언트가 호출한 횟수만큼 스레드가 생성된다는 의미입니다.

컨테이너에 동시에 실행하는 최대 스레드의 개수는 설정이 가능하며,
요청이 제한수를 넘게되면 다른것이 끝날때까지 기다려야 합니다.




* httpservletrequest와 httpservletresponse에 대해서 설명

이 메소드는 GenericServlet 클래스의 service메소드를 overriding한 메소드로서 위에서 설명한 것처럼 실제로 사용될 HTTP의 하나의 방법을 호출해 주게 됩니다. 

이 메소드는 HTTP protocol을 사용해서 넘어온 자료들을 doGet메소드나 doPost메소드를 호출하게 됩니다. 

Client로부터 넘겨진 자료의 method를 보고 GET method이면 doGet메소드를, POST 이면 doPost메소드를 호출합니다. 

만일 이 두가지의 메소드도 다 필요없이, 그냥 출력을 내보내기만 한다면(Counter를 만든다고 생각하면 별로 클라이언트로부터 자료를 넘겨 받을 것이 없지요.) 

이 service메소드를 overriding합니다. 이 메소드는 두 개의 인자를 받아 들이는데요, 하나는 HttpServletRequest이고, 또다른 하나는 HttpServletResponse입니다. 

이 두 개의 object 는 클라이언트로부터 요청받은 자료를 response와 클라이언트로부터의 자료를 요청하는 request의 역할을 해 줍니다.

- HttpServletRequest

  쿠키, 헤더, 세션 등 HTTP에 대한 것들의 처리 관련 메소드 포함

  HTTP 프로토콜에 관련된 메소드들이 추가되어 있음

  ex) getInputStream(), getCookies(), getHeader(String), getSession(), getMethod(), ...

- HttpServletResponse

  HTTP에 관련된 오류, 쿠키, 헤더정보에 대한 메소드들이 추가되어 있음

  ex) setContentType(String), getWriter(), getOutputStream(), addCookie(), addHeader(), encodeRedirectURL(), sendError(), ...





* DI에 대해서 설명

Dependency Injection의 약자로 의존성을 주입하는 것을 뜻한다. 
설정 파일을 통해 객체간의 의존관계를 설정함으로써 외부 Assembler가 객체간의 의존 관계를 정의하게 되며, 객체는 직접 의존하고 있는 객체를 생성하거나 검색할 필요가 없어지므로 코드의 관리가 쉬워진다.




* AOP에 대해서 설명

Aspect Oriented Programming을 뜻하며 기능을 핵심 비지니스 로직과 공통 모듈로 구분하고, 핵심 로직에 영향을 미치지 않고 사이사이에 공통 모듈을 효과적으로 잘 끼워넣도록 하는 개발 방법이다.

공통 모듈(보안 인증, 로깅 같은 요소등)을 만든 후에 코드 밖에서 이 모듈을 비지니스 로직에 삽입하는 것이 바로 AOP 적인 개발이다. 코드 밖에서 설정된다는 것이 핵심이다.

AOP가 사용되는 경우

1) 간단한 메소드 성능 검사
개발 도중 특히 DB에 다량의 데이터를 넣고 빼는 등의 배치 작업에 대하여 시간을 측정해보고 쿼리를 개선하는 작업은 매우 의미가 있다. 이 경우 매번 해당 메소드 처음과 끝에 System.currentTimeMills();를 사용하거나, 스프링이 제공하는 StopWatch코드를 사용하기는 매우 번거롭다.
이런 경우 해당 작업을 하는 코드를 밖에서 설정하고 해당 부분을 사용하는 편이 편리하다.

2) 트랜잭션 처리
트랜잭션의 경우 비지니스 로직의 전후에 설정된다. 하지만 매번 사용하는 트랜잭션 (try~catch부분)의 코드는 번거롭고, 소스를 더욱 복잡하게 보여준다.

3) 예외 반환
스프링에는 DataAccessException이라는 매우 잘 정의되어 있는 예외 계층 구조가 있다. 예전 하이버네이트 예외들은 몇 개 없었고 그나마도 Uncatched Exception이 아니였다. 이렇게 구조가 별로 안 좋은 예외들이 발생했을 때, 그걸 잡아서 잘 정의되어 있는 예외 계층 구조로 변환해서 다시 던지는 애스팩트는 제 3의 프레임워크를 사용할 때, 본인의 프레임워크나 애플리케이션에서 별도의 예외 계층 구조로 변환하고 싶을 때 유용하다.


4) 아키텍처 검증

5) 기타
- 하이버네티스와 JDBC를 같이 사용할 경우, DB 동기화 문제 해결
- 멀티쓰레드 Safety 관련하여 작업해야 하는 경우, 메소드들에 일괄적으로 락을 설정하는 애스팩트
- 데드락 등으로 인한 PessimisticLockingFailureException등의 예외를 만났을 때 재시도하는 애스팩트
- 로깅, 인증, 권한 등

참고사이트) http://isstory83.tistory.com/90




* 세션과 쿠키에 대해서 설명, 사용용도

Session과 Cookie 사용 이유
- 현재 우리가 인터넷에서 사용하고 있는 HTTP프로토콜은 연결 지향적인 성격을 버렸기 때문에 새로운 페이지를 요청할 때마다
 새로운 접속이 이루어지며 이전 페이지와 현재 페이지 간의 관계가 지속되지 않는다. 이에 따라 HTTP프로토콜을 이용하게 되는 
 웹사이트에서는 웹페이지에 특정 방문자가 머무르고 있는 동안에 그 방문자의 상태를 지속시키기 위해 쿠키와 세션을 이용한다.
 
Session
- 특정 웹사이트에서 사용자가 머무르는 기간 또는 한 명의 사용자의 한번의 방문을 의미한다.
- Session에 관련된 데이터는 Server에 저장된다.
- 웹 브라우저의 캐시에 저장되어 브라우저가 닫히거나 서버에서 삭제시 사라진다.
- Cookie에 비해 보안성이 좋다.
 
Cookie
- 사용자 정보를 유지할 수 없다는 HTTP의 한계를 극복할 수 있는 방법
- 인터넷 웹 사이트의 방문 기록을 남겨 사용자와 웹 사이트 사이를 매개해 주는 정보이다.
- Cookie는 인터넷 사용자가 특정 웹서버에 접속할 때, 생성되는 개인 아이디와 비밀번호, 방문한 사이트의 정보를 담은 임시 파일로써,
  Server가 아닌 Client에 텍스트 파일로 저장되어 다음에 해당 웹서버를 찾을 경우 웹서버에서는 그가 누구인지 어떤 정보를 주로 찾았는지 등을 파악할 때 사용된다.
- Cookie는 Client PC에 저장되는 정보기 때문에, 다른 사용자에 의해서 임의로 변경이 가능하다.(정보 유출 가능, Session보다 보안성이 낮은 이유)
 
Q. 보안성이 낮은 Cookie 대신 Session을 사용하면 되는데 안하는 이유?
A. 모든 정보를 Session에 저장하면 Server의 메모리를 과도하게 사용하게 되어 Server에 무리가 감





* MVC에 대해서 설명

mvc는 model-view-controller의 약자로 소프트웨어 공학에서 어플리케이션을 구성하는 패턴(pattern) 중 하나이다.

이 mvc 패턴은 응용프로그램의 시각적 부분과 가 이면의 동작과 제어를 처리하는 부분(비즈니스 로직이라 한다)을 분리하여 서로에 미치는 영향 없이도 응용프로그램을 변경할 수 있다는 장점이 있다.

예를 들어 데이터베이스나 제어프로그램의 변경 없이 시각적인 부분만 수정하려면 view에 해당하는 부분만 수정하면 되고 시각적인 부분과 관계 없이 데이터 처리 부분만 수정하려면 model 부분만, 프로그램간 연결과 제어를 수정하려면 controller 부분만 수정하면 되는 방식이다.

- Model

Model은 응용프로그램에서 데이터를 처리하는 부분을 가리킨다. 데이터베이스에 연결하고 데이터를 추출하거나 저장, 삭제, 업데이트, 변환 등의 작업을 수행하는 역할을 한다.

- View

View는 화면에 표시되는 부분이다. 추출한 데이터나 일반적인 텍스트 데이터를 표시하거나 입력폼 또는 사용자와의 상호작용을 위한 인터페이스를 표시하는 영역이다.

- Controller

Controller는 어플리케이션에서 각 요소들의 연결관계를 설정하고 데이터와 시각적 부분의 연결 등을 관리한다. 대개 url로부터 입력되는 정보로부터 어떤 데이터와 뷰를 연결할 지 등을 제어한다.

사용자가 Controller에 작업을 요청하면 Controller는 Model을 호출하여 데이터를 처리하고 Model이 데이터를 처리한 결과를 View에 보내고 이 결과를 사용자가 보게 된다는 것이다.




* WAS란?

Web Server

웹서버는 클라이언트/서버 모델과 웹의 HTTP를 사용하여 웹 페이지가 들어 있는 파일을 사용자들에게 제공하는 프로그램이다. 웹사이트가 운영되고 있는 인터넷상의 모든 컴퓨터들에는 모두 웹서버 프로그램이 설치되어 있다. 가장 보편적인 웹서버들로는 32 비트 윈도우와 유닉스 기반의 운영체계에서 모두 쓸 수 있는 아파치와, 윈도우 NT에 딸려 나오는 IIS, 그리고 넷스케이프의 엔터프라이즈 서버 등이 있다. 그밖에 네트웨어 운영체계를 쓰는 사용자들을 위한 노벨의 웹서버, 주로 IBM의 OS/390과 AS/400 고객들을 위한 IBM의 로터스 도미노 서버를 비롯, 다른 웹서버들도 있다.
웹서버들은 흔히 전자우편, FTP 파일의 다운로드, 그리고 웹페이지 구축, 발간 등에 필요한 인터넷 및 인트라넷과 관련된 프로그램들의 커다란 패키지의 일부로서 나온다. 웹서버를 고를 때 고려해야할 사항으로는, 운영체계나 다른 서버들과 얼마나 잘 어울려 동작할 것이냐 하는 것과, 서버 측의 프로그래밍, 퍼블리싱, 검색엔진 등을 처리하는 능력, 그리고 함께 따라오는 구축도구 등이 있다.

WAS (Web Application Server)
웹과 기업의 기간 시스템 사이에 위치하면서, 웹 기반 분산 시스템 개발을 쉽게 도와주고 안정적인 트랙잰션 처리를 보장해 주는 일종의 미들웨어 소프트웨어 서버.

3계층 웹 컴퓨팅 환경에서 기존 클라이언트/서버 환경의 애플리케이션 서버와 같은 역할을 하며, 클라이언트와 서버 환경에서 트랜잭션 처리및 다른 기존 시스템 간의 애플리케이션 연동을 등을 주된 기능으로 하고 있다. 

요즘들어서는 WAS는 주로 데이터베이스 조회나 일반적인 비즈니스 로직에 대한 처리를 위해 다양한 언어로 개발된 인터넷/인트라넷 환경의 소프트웨어로 많이 불리운다. 자바스크립트나 JSP 등과 같은 스크립트 및 서비스들은 대개 최신의 데이터를 검색하기 위해 데이터베이스에 접근하고, 브라우저 또는 클라이언트 프로그램을 통해 사용자들에게 검색 결과를 제공한다.

WAS를 비롯한 애플리케이션 서버들은, 웹서버 즉 HTTP 서버와 같은 컴퓨터를 공유할 수도 있지만 별개의 컴퓨터를 독립적으로 사용하는 경우도 많다. 대규모 사이트에서는, 오히려 WAS와 웹서버 등을 위해 여러 대의 컴퓨터가 동원되기도 한다. 
넷스케이프의 Netscape Application Server, Bea의 Weblogic Enterprise, 볼랜드의 Appserver, 그리고 IBM의 Websphere Application Server 등의 WAS 대표적인 제품들이다.

※Web Server와 WAS와 차이※

- Web Server 의 정의 : Web Client(웹 브라우저)에게 컨텐츠를 제공하는 서버, 정적인 HTML이나 jpeg, gif 같은 이미지를 HTTP 프로토콜을 통해 웹 브라우저에게 전송하는 역할

- WAS(Web Application Server)의 정의 
○ Server 단에서 Application을 동작할 수 있도록 지원함 => Jeus
○ 기존 웹 서버와 달리 동적인 요구에 대응하기 위해 적합한 형태로 변화, Web Client(브라우저)에게는 결과값만 전송함.
○ Container(컨테이너)라는 용어로 쓰이며, 초창기는 CGI, 그 후에서는 Servlet, , JSP, ASP 등의 프로그램으로 사용됨

- Web Server와 WAS의 구성에 따른 분류
○ WAS와 WebServer를 분리하지 않는 경우 
모든 컨텐츠를 한곳에 집중시켜 웹서버와 WAS의 역할을 동시에 수행, 스위치를 통한 로드 밸러싱, 사용자가 적을 경우 효율적

○ WAS와 WebServer를 분리한 경우 
웹서버와 WAS의 기능적 분류를 통해 효과적인 분산을 유도, 정적인 데이터는 웹서버에서 처리, 동적인 데이터는 WAS가 처리

○ WAS 여러개와 WebServer를 분리한 경우
WAS단을 프리젠테이션 로직와 비즈니스 로직으로 구분하여 구성, 특정 logic의 부하에 따라 적절한 대응할 수 있지만 설계단
계 유지보수 단계가 복잡해 질 수가 있다. 

WAS 와 Web Server 종류

○ WAS 종류
tomcat, tMax jeus, BEA Web Logic, IBM Webspere, JBOSS,Bluestone, Gemston, inprise, Oracle, PowerTier,Apptivity,
silverStream
○ Web Server 
IIS, apache, tMax, WebtoB

- tomcat
아파치 소프트웨어 재단의 애플리케이션 서버로서, 자바 서블릿을 실행시키고 JSP 코드가 포함되어 있는 웹페이지를 만들
어준다. 자바 서블릿과 JSP 규격 '참조용 구현'으로 평가되고 있는 톰캣은, 개발자들의 개방적 협력 작업의 산물로 바이너리
버전과 코어버전 둘 모두를 아파치 웹사이트에서 얻을 수 있다. 톰캣은 자체적으로 보유하고 있는 내부 웹서버와 함께 독립
적으로 사용 될 수도 있지만 아파치나 넷스케이프 엔터프라이즈 서버, IIS, 마이크로소프트의 PWS 등 다른 웹서버와 함께 사
용할 수도 있다. 톰캣을 실행시키기 위해서는 jre 1.1 이상에 부합되는 자바 런타입 환경이 필요하다.




* jsp:include, @ include 차이(정적,동적 include의 차이)

1. 정적인 include 지시문의 예 : <%@include file="/jsp/common/session.jsp"%>

정적이란 단어에 이미 모든 의미가 함축되어 있다. 

jsp 파일이 java 파일로 수정되기 전에 session.jsp 파일의 모든 내용이 부모의 jsp 로 include 된다. 

그 후에 부모의 jsp 는  java -> class 파일-> html 문서 -> 웹 브라우저로 랜더링 된다. 

따라서 session.jsp 파일 안에서 전역변수로 String greeting = "Hello Wordl"; 라고 정의했다면 session.jsp 를 사용하는 부모 jsp 에서는 서브릿 태그(<%%>) 에서 컴파일 에러 없이 바로 greeting 변수를 사용할 수 있다.


2. 동적인 include 지시문의 예 :

<jsp:include page="/jsp/common/uppermenu.jsp" flush="true">
</jsp:include>

동적이란 단어에 이미 모든 의미가 함축되어 있다. 

uppermenu.jsp 는 부모 jsp 가 java->class -> html 문서로 수정되어 실행되어질 시점에 삽입 된후 웹 브라우저로 랜더링 된다. 

즉 정적 include  지시자 처럼 uppermenu.jsp 안에서 서브릿 태그를 선언하고 전역변수를 만든후에 부모 jsp 에서 그 변수를 사용할 수 없다. 

동적 jsp 는 해당 파일이 수정되는 경우 다시 컴파일이 진행된다.




* pagecontext, request, session, application 참조범위

JSP 영역이란? 한개 이상의 JSP가 모인 그룹을 뜻한다

영역의 종류는  [ PageContext / Request / Session / Application ]
그 중 JSP에서 제공해주는 내장객체는 Request, Session, Application이다.

1. Page Context : 현재 처리되고 잇는 한개의 그 페이지 영역
이 Page 영역은 위의 3가지 영역과는 다르게 Page의 내장객체가 아닌 pageContext 내장객체를 통해 접근할 수 있는 영역이다

→ A페이지에서 pageContext.setAttribute()를 할 시 넘어간 B페이지에서 관련된 속성을 사용할 수 없다.

2. Request
- request 객체가 포워드 되는 영역에서 사용되는 객체
- request 객체 자체는 포워드해져야 의마가 있으며 소멸되는 성질을 가지고 있다.
즉, 요청하고 포워드하는 그 과정의 jsp를 request영역이라고 부른다.
그리고 request 영역에서 공유되는 개체

→ 예를 들어 A페이지와 B페이지가 있었을 때, A에서 B페이지로 request를 하면 AB는 동일한 request 객체를 사용할 수 있다.
→ getServletContext().getRequestDispatcher(URL).forward(req,res);
→ request.setAtrribute()로 사용가능하다.

3. Session : 한 이용자가 한 사이트에서 지나가는 모든 페이지 영역에서 사용하는 객체
session은 맨처음 딱 한번 생성되고 페이지를 이동할 때마다 그 session이 유지된다.
100명이 접속했으면 100개의 session이 생긴다
이러한 session 생성은 톰캣에서 하는 것이다

→ 어디서든 사용이 가능하다
만약 로그아웃 기능을 하고 싶다면 removeAttribute() 기능을 사용하면 된다.

4. Application : 한 사이트에 속해 있는 모든 페이지 영역에서 사용되는 객체
server (톰캣)이 구동 될 때 생기는 객체이다.
모든 이가 공유할 수 있는 데이터이다. 

→ 가장 큰 영역이다




* 프레임워크란?

- 특정 형태의 소프트웨어 문제를 해결하기 위해 상호 협력하는 클래스프레임과 인터페이스 프레임의 집합
- 특정한 틀을 만들어놓고 거기에 살을 붙여 놓음으로써 프로그램을 만들어 작업시간을 줄여주는 것이다. 
  스켈레톤 코드라고도 하는데, 뼈대가 이미 만들어져 있어서 거기에 살(기능)만, 덧붙이면 완성이 되도록 공통된 함수 또는 클래스를 미리 만들어 놓는 것을 이야기한다.
- 프레임워크는 특정 개념들의 추상화를 제공하는 여러 클래스나 컴포넌트로 구성된다.
- 프레임워크는 이렇게 추상적인 개념들이 문제를 해결하기 위해 같이 작업하는 방법을 정의한다.
- 프레임워크 컴포넌트 들은 재사용이 가능하다.
- 프레임워크는 좀 더 높은 수준에서 패턴을 조작한다.
* 프레임워크가 중요한 이유는 객체지향 개발을 하게 되면서 개발자의 취향에 따라 다양한 프로그램이 나오게 되었다.
 프로그램 개발에 투입되는 개발자도 점점 늘어남에 따라 전체 시스템의 통합성, 일관성이 부족하게 되었기 때문이다. 
 그래서 개발자의 자유를 제한하기 위해 프레임워크를 도입했다.
프레임워크가 가져야할 특징
a. 개발자들이 따라야할 가이드라인을 가진다.
b. 개발할 수 있는 범위가 정해져 있다.
c. 개발자를 위한 다양한 도구들이 지원된다.
프레임워크의 장/단점
장점 - 개발 시간을 줄일 수 있고 오류로부터 자유로울 수 있다.
단점 - 프레임워크에 너무 의존하면 개발 능력이 떨어져서 프레임워크 없이 개발하는 것이 불가능해지는 점이다.





* 프레임워크 사용시 장점

1. 코드 품질을 보장하기 위해
2. 백지의 압박이 싫어서
3. 언어의 표준화
4. 유지보수성
5. 개발 편의
6. 뒤쳐지지 않고 있다는 위안

- 코드 품질을 보장하기 위해

저희 개발팀에 프레임워크라는 것을 처음 도입한 유일한 이유는 코드 품질 때문이였습니다. 품질을 향상 시키려는 게 아니고 품질을 떨어트리지 않으려고...;;;

저랑 한두 명이 일할 때는 제가 모든 사람의 코드를 살펴 보고 문제가 있는 부분은 지적해서 고치게 했었습니다. 작동만 하면 된다는 것은 저한테 통하지 않았기 때문에 저 때문에 많이 힘들어 했었을 겁니다. 다른 사람이 자기 코드를 한줄한줄 짚어가면서 잘못을 지적한다면 무척 기분 나쁘겠죠. 하지만 남의 돈을 받아가면서 일을 하는 이상 일정한 품질은 반드시 유지해야 한다고 생각했습니다. 저도 사회 초년생일 때에 저희 상사에게서 그렇게 배웠구요. 저도 기분 나빴지만 솔직히 배우는게 더 많았습니다.

그런데 사람들이 더 늘어나면서 품질에 문제가 생기기 시작했습니다. 저도 제가 맡은 분량이 있으니 모든 사람의 코드를 다 살펴보는 것이 사실상 불가능해진 것이죠. 문제는 여기저기서 생기고... 이미 그렇게 하면 안된다는 것을 다른 사람들은 알고 있었지만 신입사원에게 그것이 전달되는 시스템은 없었던 것입니다.

개발팀이 체계적으로 잘 만들어져서 운영된다면 따로 교육기간도 있고 품질 관리나 개발 방법론 같은 것도 정립되어야 할 것 같지만 저희 같이 작은 회사에서 그런 것을 다 만든다는 게 힘들 뿐 아니라 솔직히 오히려 부작용만 있을 수 있다는 생각이 있습니다. 오히려 문화를 만들고 공유하는 것이 더 효과적이지요.

같은 언어를 쓰고 같은 방식으로 설계하고 구축하는 것이 정착된다면 품질 때문에 문제가 되는 일이 많이 줄어들 것이라 생각했고 그래서 적당한 프레임워크를 도입하거나 만들어 쓰게 되었습니다.

혼자 일한다면야 이런 부분에서 문제를 별로 느끼지 못하시겠지만 팀의 품질을 일정 수준으로 유지해야만 하는 상황, 더구나 특별히 누군가가 그 일을 위해서 시간을 투자해 신경을 쓸 수 없는 상황에서 적절한 프레임워크를 도입하게 되면 많은 효과가 있는 듯 합니다.

그러나 외부의 프레임워크를 그대로 가져다 쓰면 이것이 자연스럽게 해결되지는 않더군요. 오히려 이 프레임워크를 더 다듬어서 다양한 사례에 적용해보고 그 결과를 공유하는 작업이 필요했습니다. 저 같은 경우는 이 부분에서 신경을 쓰지 못해서 수년 동안 문제 있는 코드가 회사 내에 유령처럼 떠돌아다니는 상황을 목격했습니다. 

이런 코드는 사실 제가 투입되지 않았던 프로젝트에서 대부분 생산이 되었는데 이것을 없애기가  바퀴 벌래 박멸 보다 더 힘들어 보입니다. 사실 제가 포기하고 말았지요. 결국 아키텍처는 그 프레임워크로 어플리케이션을 개발하는 사람 중 하나가 만들어야 한다는 말은 진짜 옳은 말입니다.

- 백지의 압박이 싫어서

무슨 일을 할 때에 일을 하는 순서가 정해진 것과 매번 백지에서 하는 것과는 심리적으로 느끼는 부담감이 다릅니다. 프레임워크는 이런 부담을 많이 줄여줍니다. 일의 순서가 정해져 있으니 그것을 따라 하면 되는 것이죠. TDD가 주는 부수적인 이점도 비슷하다고 생각합니다. 일단 돌려서 결과를 볼 수 있다는 게 개발의 지루함을 많이 줄여주게 되니까요.

프레임워크를 사용한 다양한 예제가 있다면 더욱 좋다고 생각합니다. 저도 대부분 예전에 작업했던 코드를 가져다 수정하는 방식으로 개발을 많이 하는데 프레임워크가 사용하지 않았다면 이런 일은 어렵겠죠. 매번 새로운 프레임워크를 써야 하는 상황이라면 조금 다르다고 생각하는 분이 계시겠지만 같은 방식의 프레임워크 간의 포팅은 완전히 새로 짜는 것 보다 쉽게 느껴지더군요. 예를 들어 struts로 개발한 코드를 struts2나 spring mvc로 포팅하는 것은 쉬운데 tapestry나 jsf로 포팅하는 것은 비용이 많이 들겠죠. 저는  struts의 코드를 spring mvc로 포팅해서 구축한 경험이 있었는데 그리 어렵지 않았습니다. 처음부터 다시 짠 것 보다 더 빨리 작업했는지는 모르겠지만 적어도 맘은 편했습니다. ^^

- 언어의 표준화

앞의 코드 품질과 관계되기도 하는데 개발 할 때에 프레임워크를 도입하게 되면 자연히 그 개발 철학과 언어도 같이 들어오게 됩니다. 그러면서 자연히 언어가 통일되게 되죠. 서로 대화도 편해지고 명확해집니다. 자연히 사고 방식도 맞춰지구요.

- 유지보수성

다른 사람이 만든 코드를 들여다 보는 게 얼마나 힘든 일인지 개발자들이라면 다 알겁니다. 그걸 수정하느니 다시 만드는 게 낫다고들 하죠. 그런데 그게 타사의 개발자가 만든 코드가 아닌 같은 회사의 개발자가 만든 코드라면 좀 문제가 심각한 것이겠죠.

저는 기본적으로 같은 회사의 개발자들은 큰 부담 없이 서로의 코드를 이해 할 수 있어야 한다고 생각합니다. 그래야 품질도 어느 수준에서 보장되는 것이고 유지보수 비용도 적게 들게 되는 것이고 재사용도 할 수 있게 되죠.

프레임워크를 사용하면 그런 면에서 많은 도움을 받을 수 있습니다. 저는 어떤 일을 하게 되면 동료들에게 비슷한 경우가 있었는지 물어보고 그 코드를 가져다 수정하는 식으로 작업을 합니다. 물론 이렇게 하려면 프레임워크를 어떻게 사용 할지에 대한 것도 시간이 지남에 따라 어느 정도 정형화 되어야 하겠지요. 

- 개발 편의

대부분의 프레임워크들은 개발을 편하게 하기 위한 다양한 기능들을 가지고 있습니다. 이런 것은 제가 따로 만들 수도 있겠지만 제 경험상 프레임워크에서 제공해주는 코드가 제가 만든 것 보다 훨씬 낫더군요. 저 보다 똑똑한 사람이 만든 게 분명해 보였습니다. ^^

뒤쳐지지 않고 있다는 위안

개발자라면 늘 최신 기술 흐름에서 떨어지지 않으려는 욕심이 있을 겁니다. 모든 것을 외부의 도움 없이 스스로 해결 할 수도 있겠지만 어느 한 순간 우물 안 개구리가 되는 경우도 있지요. 꼭 트렌드를 따라야 한다고 말하고 싶지는 않구요. 오히려 남들이 안하는 특수 분야를 파고 드는 것이 장점이 될 수도 있다는 것은 인정합니다. 하지만 전 좀 남들에게 개발자로 인정 받고 싶은 욕심이 있어서 그런지 외골수로 파고들기 보다는 약간은 흐름을 타고 싶더라구요.




* ORM이란? (Object/Relational Mapping)

Rational Database에서는 데이터를 집합 이론을 이용하여 저장하고 처리.

Objective Oriented System에서는 객체와 객체들 사이의 관계를 이용하여 프로그래밍.

이 둘간의 차이점으로 인한 문제 발생

프로그래밍 단에 객체와 관계형 데이터베이스를 mapping해주는 새로운 abstracted layer를 도입하고, 

프로그래머는 이 레이어를 이용하여 객체지향적으로 database programming을 하는 것.

구체적으로 말하자면, DAO(Data Access Objects)를 얼마나 편하게 만들 수 있느냐는 것이다.

ORM을 사용하지 않아도 DAO를 통해 유연하고, 확장성 있는 system을 얼마든지 만들 수 있다. 

또한 DAO를 사용하는 client는 DAO 구현체가 ORM을 사용했는지 아니면 JDBC 등을 이용해 직접 코딩했는지 알지 못한다.

ORM의 기본적이며 가장 중요한 목적은

1. 보다 편리하고 빠른 데이터베이스 프로그래밍

2. Agile database programming(에자일 데이터베이스 프로그래밍)

대표적으로 Hibernate. iBatis, Spring JPA 등

보통 ORM Framework들은 이러한 이질성을 해결하기 위해서 객체와 table간의 관계를 설정하여 자동으로 처리를 해준다는 것이다.

참고사이트) http://civan.tistory.com/156

ORM

Object-Relational Mapping이란 이름 그대로 객체와 관계형 DB를 매핑해주는 것이다. 

ORM은 객체와 테이블을 매핑하기 때문에 SQL쿼리를 직접 날리는 것이 아니라 마치 자바에서 라이브러리 사용하듯이 사용하면 된다. 

orm은 다음 과 같은 일을 해준다.

- Entity 분석

- 쿼리 생성

- JDBC API 사용

- Result Set 매핑

- 패러다임 불일치 해결





* DAO와 DTO에 대해서 설명

== DAO란 

Data Access Object의 약어로서 실질적으로 DB에 접근하는 객체를 말한다.

DAO의 사용 이유는 효율적인 커넥션 관리와 보안성 때문이다.

- 정의

DAO란? 한마디로 Database의 data에 access하는 트랜잭션 객체이다. 

일종의 객체라는 것을 잊지말도록 하자. DAO는 저수준의 Logic과 고급 비지니스 Logic을 분리하고, 

domain logic으로부터 persistence mechanism을 숨기기 위해 사용한다. 

(적절히 디자인을 하면 모든 domain logic을 바꾸는 대신에 DAO를 바꾸기만 하면 된다.)

persistence 계층 : Database(영구 저장소)에 data를 CRUD하는 계층

// Create , Read , Update , Drop의 줄임말

- 설명

웹서버는 DB와 연결하기 위해서 매번 커넥션 객체를 생성하는데, 이것을 해결하기 위해 나온것이 컨넥션 풀입니다. 

ConnectionPool 이란 connection 객체를 미리 만들어 놓고 그것을 가져다 쓰는것입니다. 

또 다쓰고 난 후에는 반환해 놓는 것. 하지만 유저 한명이 접속해서 한번에 하나의 커넥션만 일으키지 않고 

게시판 하나만 봐도 목록볼때 한번, 글읽을때마다 한번, 글쓸때 한번 등등... 엄청나게 많은 커넥션이 일어나기에,

 커넥션풀은 커넥션을 또 만드는 오버헤드를 효율적으로 하기 위해 DB에 접속하는 객체를 전용으로 하나만 만들고, 

모든 페이지에서 그 객체를 호출해다 사용한다면? 이렇게 커넥션을 하나만 가져오고 그 커넥션을 가져온 객체가 

모든 DB와의 연결을 하는것이 바로 DAO객체입니다^^

DAO(Data Access Object)는 DB를 사용해 데이터를 조화하거나 조작하는 기능을 전담하도록 만든 오브젝트를 말한다.

사용자는 자신이 필요한 Interface를 DAO에게 던지고 DAO는 이 인터페이스를

구현한 객체를 사용자에게 편리하게 사용 할 수 있도록 반환해줍니다.

 DB에 대한 접근을 DAO가 담당하도록 하여 데이터베이스 엑세스를 DAO에서만

하게 되면 다수의 원격호출을 통한 오버헤드를 VO나 DTO를 통해 줄일 수 있고

다수의 DB 호출문제를 해결할 수 있습니다. 또한 단순히 읽기만 하는 연산이므로

트랜잭션 간의 오버헤드를 감소할 수 있습니다.(?)


== DTO란

DTO(Data Transfer Object)는 VO(Value Object)로 바꿔 말할 수 있는데

계층간 데이터 교환을 위한 자바빈즈를 말한다. 여기서 말하는 계층간의

컨트롤러, 뷰, 비즈니스 계층, 퍼시스턴스 계층을 말하며 각 계층간 데이터 교환을

위한 객체를 DTO 또는 VO라고 부른다.

[그런데 VO는 DTO와 동일한 개념이지만 read only 속성을 가짐 ]

대표적인 DTO로는 폼데이터빈, 데이터베이스 테이블빈 등이 있으며, 각 폼요소나, 데이터베이스 레코드의 데이터를 

매핑하기 위한 데이터 객체를 말한다. 즉 폼 필드들의 이름을 그대로 가지고 있는 자바빈 객체를 폼 필드와 그대로 

매핑하여 비즈니스 계층으로 보낼 때 사용한다. 이런 객체를 DTO라고 부르며 VO(Value Object) 패턴이라고도 한다.

VO 패턴은 데이터 전달을 위한 가장 효율적인 방법이지만, 클래스 선언을 위해 많은 코드가 필요하다는 단점이 있다.

일반적인 DTO는 로직을 갖고 있지 않다. 순수한 데이터 객체이며 속성과 그 속성에 접근하기 위한 getter, setter 

메소드만 가진 클래스를 말한다. 여기에 추가적으로 toString(), equals(), 등의 Object 클래스 메소드를 작성할 수 있다.

즉, 계층 간의 데이터 전달에 사용하는 데이터 객체들을 말한다.





* Spring 프레임워크와 전자정부 프레임워크의 차이점(?)

전자정부 표준프레임워크는 대한민국의 공공부문 정보화 사업 시 플랫폼별 표준화된 개발 프레임워크를 말한다.

JAVA 언어는 사설 표준으로 우후죽순으로 업체의 자체 프레임워크를 개발하여 적용되다 보니 각 개발프레임워크의 구조 

및 수준의 차이에 의하여 여러 가지 문제점이 발생할 수 있다.

현재 배포되고 있는 프레임워크는 과거 JAVA 플랫폼 기반의 정보화 구축 사업 시 수행업체의 자체 개발프레임워크를 

사용하여 정보시스템이 구축되어 유지보수 등 여러 가지 문제점이 있어, 2008년에 스프링 프레임워크 등의 오픈소스를 

기반으로 웹 사이트 개발 시 필요한 여러 가지 기능들을 미리 구현해 놓았으며 최근에는 모바일 개발을 위한 프레임워크도 출시되었다.